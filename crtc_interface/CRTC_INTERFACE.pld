Name        CRTC_INTERFACE;
PartNo      00;
Date        07/18/2025;
Revision:   01;
Designer:   George Foot;
Company:    nunya;
Assembly    none;
Location    none;
Device      g22v10;

pin 1 = clk; /* 25.175 mhz */
pin 2 = clk_in; /* 25.175 mhz unnecesary now, but still here */
pin 3 = display_enable_in;
pin 4 = vsync_in;
pin 5 = hsync_in;

pin 14 = !hsync_out; /* delayed inverted hsync */
pin 15 = !vsync_out; /* delayed inverted vsync */
pin 16 = !blank_out; /* delayed  display_enable_in */
pin 17 = !SR_PE; /* shift register parallel load enable */
pin 18 = clk_inv; /* inverted 1/2 clock (!clk_half, 12.5mhz), asynchronous sr clock */
pin 19 = clk_half; /* noninverted 1/2 clock (12.5mhz) */
pin 20 = clk_quarter; /* 6mhz */
pin 21 = !CCLK; /* 1/16 clock - MC68B45 cclk signal 1.5xx mhz */
pin 23 = clk_eighth; /* 3.xx mhz */

Field C = [!CCLK, clk_eighth, clk_quarter, clk_half];
SequenceD C {
    $REPEAT i = [0..15]
        Present 'h'{i}
            Next 'h'{(i+1) % 16};
    $REPEND
}

/* 
    display_enable_in is HIGH when display is enabled for signal
    and LOW when it's in the blanking region.This is how MC6845 works

    shift register is clocked by the input clock (pixel clock)
   after !CCLK goes low, the crtc changes address, hsync, vsync, blank, etc
   addresses could take nearly 4 pixel clocks to settle, others longer

   so we will reload the shift register at the last opportunity before !CCLK falls
   and triggers a new cycle

    note that due to the synchronous clocking, !SR_PE goes low on the cycle after
    the one we specify here. and also, during blanking we want to just let all the bits
    shift out and not get reloaded at all
*/ 
!SR_PE.d = !(C:E) # !display_enable_in;

/* delay and invert the sync and blank signals */
!hsync_out.d = (!(C:E) & !hsync_out) # (C:E & !hsync_in);
!vsync_out.d = (!(C:E) & !vsync_out) # (C:E & !vsync_in);
!blank_out.d = (!(C:E) & !blank_out) # (C:E & !display_enable_in);

/* also provide an asynchronous inverted clk in case that's useful */
clk_inv = !clk_half;